import { deleteData, fetchData, postData, updateData } from './userApi';
import { User, UserResponse, UserWithComments } from './../../common/types';
import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../../app/store';

export interface initalUserState {
    user: UserResponse,
    userWithComments: UserWithComments,
    users: UserResponse[],
    usersConst: UserResponse[],
    isLoading: boolean,
    filter: {page: number, rowsPerPage: number}
}

const initialState: initalUserState = {
  user: {id: 0, name: "", email: "", password: "", created_at: "", updated_at: ""},
  userWithComments: {id: 0, name: "", email: "", password: "", created_at: "", updated_at: "", comments: []},
  users: [],
  usersConst: [],
  isLoading: false,
  filter: {page: 0, rowsPerPage: 3}
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
// export const incrementAsync = createAsyncThunk(
//   'counter/fetchCount',
//   async (amount: number) => {
//     const response = await fetchCount(amount);
//     // The value we return becomes the `fulfilled` action payload
//     return response.data;
//   }
// );

export const fetchUsers = createAsyncThunk(
    'user/fetchUsers',
    async () => {
        const response = fetchData<UserResponse[]>('customers')
        console.log("response", response)

        return response;
    }
)


export const createUser = createAsyncThunk(
  'user/createUser',
  async (user: User) => {
      const response = postData<User, UserResponse>(`customers`, user)
      console.log("response", response)

      return response;
  }
)

export const updateUser = createAsyncThunk(
  'user/updateUser',
  async (paylaod: {user: User, id: string}) => {
      const response = updateData<User, UserResponse>(`customers/${paylaod.id}`, paylaod.user)
      console.log("response", response)

      return response;
  }
)

export const fetchUserById = createAsyncThunk(
  'user/fetchUserById',
  async (id: string | undefined) => {
      const response = fetchData<UserWithComments>(`customers/${id}/comments`)

      console.log("response", response)

      return response;
  }
)

export const deleteUser = createAsyncThunk(
  'user/deleteUser',
  async (id: number | undefined) => {
      const response = deleteData(`customers`,id || 1)

      console.log("response", response)

      return id;
  }
)

export const deleteUserComment = createAsyncThunk(
  'user/deleteUserComment',
  async (id: number | undefined) => {
      const response = deleteData(`comments`,id || 1)

      console.log("response", response)

      return id;
  }
)

export const userSlice = createSlice({
  name: 'user',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    updateUsersPagination: (state, action) => {
      state.filter = {...state.filter, page: action.payload}
    },
    UpdateUsersRowsPerPage: (state, action) => {
      state.filter = {...state.filter, rowsPerPage: action.payload}
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        console.log("action", action.payload)
        state.isLoading = false;
        state.users = action.payload
      })
      
      .addCase(fetchUsers.rejected, (state) => {
        state.isLoading = false;
      })
      
      builder.addCase(fetchUserById.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(fetchUserById.fulfilled, (state, action) => {
        state.isLoading = false;
        state.userWithComments = action.payload
      })
      .addCase(fetchUserById.rejected, (state) => {
        state.isLoading = false;
      })

      builder.addCase(createUser.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(createUser.fulfilled, (state, action) => {
        state.isLoading = false;
        let newUser: UserResponse = {...action.payload}

        let newUsersList: UserResponse[] = [newUser, ...state.users]
        
        state.users = newUsersList
      })
      .addCase(createUser.rejected, (state) => {
        state.isLoading = false;
      })

      builder.addCase(updateUser.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(updateUser.fulfilled, (state, action) => {
        state.isLoading = false;

        state.userWithComments = {...action.payload, comments: state.userWithComments.comments};
      })
      .addCase(updateUser.rejected, (state) => {
        state.isLoading = false;
      })

      builder.addCase(deleteUser.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(deleteUser.fulfilled, (state, action) => {
        state.isLoading = false;

        let newUsersList = state.users.filter(item => item.id !== action.payload)

        state.users = newUsersList
      })
      .addCase(deleteUser.rejected, (state) => {
        state.isLoading = false;
      })
      
      builder.addCase(deleteUserComment.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(deleteUserComment.fulfilled, (state, action) => {
        state.isLoading = false;

        let newUsercomments: UserWithComments = {...state.userWithComments, comments:
           state.userWithComments.comments.filter(item => item.id !== action.payload)}

        state.userWithComments = newUsercomments
      })
      .addCase(deleteUserComment.rejected, (state) => {
        state.isLoading = false;
      })
      
  },
});

export const { updateUsersPagination, UpdateUsersRowsPerPage } = userSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`

export const users = (state: RootState) => {

    return state.user.users;
  }

export const filterdUsers = (state: RootState) => {

  let filterdUsers: UserResponse[] = [];

    let startIndex = (state.user.filter.page + 1) * state.user.filter.rowsPerPage - state.user.filter.rowsPerPage;
    let endIndex = (state.user.filter.page + 1) *  state.user.filter.rowsPerPage;

    filterdUsers = state.user.users.slice(startIndex, endIndex);

    console.log("users list", filterdUsers)

    return filterdUsers;
  }

export const userPage = (state: RootState) => state.user.filter.page

export const userRowPerPage = (state: RootState) => state.user.filter.rowsPerPage

export const user = (state: RootState) => state.user.user;

export const userWithComments = (state: RootState) => state.user.userWithComments;


export const isLoading = (state: RootState) => state.user.isLoading;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd =
//   (amount: number): AppThunk =>
//   (dispatch, getState) => {
//     const currentValue = selectCount(getState());
//     if (currentValue % 2 === 1) {
//       dispatch(incrementByAmount(amount));
//     }
//   };

export default userSlice.reducer;
